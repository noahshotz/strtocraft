def find_combinations(input_str, dictionary):
    # Create a list to store the best combinations for each position in the input string
    # Initialize it with an empty list for the first 4 positions and None for the rest
    dp = [[] for _ in range(min(4, len(input_str)))] + [None] * (len(input_str) - 4)

    # Iterate through each position in the input string
    for i in range(1, len(input_str) + 1):
        # Initialize a list to store the combinations for the current position
        current_combinations = []
        
        # Iterate through each string in the dictionary
        for word in dictionary:
            # Check if the current word can be appended to the current position
            if input_str[i - len(word):i] == word:
                # Calculate the previous position index
                prev_position = i - len(word)
                
                # If the previous position is valid, add the word to the combinations
                if prev_position >= 0:
                    for prev_combination in dp[prev_position]:
                        new_combination = prev_combination + (word,)
                        current_combinations.append(new_combination)

        # Sort the combinations by length and keep only the top 4
        current_combinations.sort(key=len)
        dp.append(current_combinations[:4])

    # The last position in dp contains the best combinations
    return dp[-1]

